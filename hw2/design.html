<!DOCTYPE html>
<meta charset="utf-8">
<title>Homework 2 Graph</title>
<style>

    .slider-width{
        width: 440px;
        vertical-align: top;
        position: relative;
        top: -3px;
    }

    .interactive{
        width:120px;
        float: left;
    }

    .chord {
        stroke: black;
        /*stroke-width: .8px;*/
        /*stroke-opacity: .4;*/
    }

    .node{
        fill: white;
        stroke: #000;
        stroke-width: .9px;
    }

    .node--source {
        fill: black;
    }

    .node--target{
        fill: black;
    }

    .chord--source{
        stroke: black;
        stroke-opacity: 1;
    }

    .hidden{
        opacity: .4;
        stroke-opacity: .4;
    }

    div.tooltip {
        position: absolute;
        text-align: center;
        width: 60px;
        height: 28px;
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
    }

    .selectSlice {
        fill: black ;
    }

    .partnerName {
        display: block;
        color: black;
        font-weight: bold;
        /*width: 20px;*/
        /*height: 50px;*/
        /*line-height: 10px;*/
        /*text-align: center;*/
        /*text-ver: middle;*/
        font-family : "Helvetica Neue";
        font-size : 12px;
    }

    .current_country {
        display: block;
        color: black;
        font-weight: bold;
        width: 300px;
        height: 50px;
        line-height: 50px;
        text-align: center;
        text-ver: middle;
        font-family : "Helvetica Neue";
        font-size : 20px;
    }


    #container_main {height: 710px; width:1293px; font-size:0;}
    #left_panel, #right_panel {display: inline-block; *display: inline; zoom: 1; vertical-align: top; font-size: 16px;}
    #left_panel {height: 100%; width: 75%; background: white;}
    #right_panel {height: 100%; width: 25%; background: white;}
    #top_left_panel {height: 5%; width: 100%; background: white;}
    #bottom_left_panel {height: 95%; width: 100%; background: white;}

</style>
<body>
<!--<script src="http://d3js.org/d3.v3.min.js"></script>-->
<script src="src/d3.v3.min.js"></script>

<div id="container_main">
    <div id="left_panel">
        <div id="top_left_panel">
            <!--Select Year-->
            <label >
                <label class = interactive>Year:</label>
                <label id="minYear">1995 </label>
                <input class="slider-width" type="range" name="points" width = "300" min="1995" max="2012" step="1" value="0" id="slider-time" oninput=";">
                <label id="maxYear">2012</label>
            </label>
        </div>
        <!--SVG Main-->
        <div id="bottom_left_panel">
        </div>
    </div>
    <!--Legend & Select Attributes Panel-->
    <div id="right_panel">
        <div>
            <form id="continents_sorting_container">
                <label><input onchange="" type="checkbox" name="continent_sorting_val" value="continent_sorting_val"> Combine Like Continents</label>
            </form>
        </div>
        <div>
            <form>
                Country Sorting:
                <select id="country_sorting_val" onchange="" name="country_sorting_val">
                    <option value="name" selected="selected">Name</option>
                    <option value="population">Population</option>
                    <option value="gdp">GDP</option>
                </select>
            </form>
        </div>
        <div>
            <label class="current_country" id="current_country">United States</label>
        </div>
        <div>
            <form id="partners_sorting_container">
                Export Partner Sorting:
                <select id="aster_sorting_val" onchange="" name="aster_sorting_val">
                    <option value="p_total_export" selected="selected">Amount</option>
                    <option value="p_mutuality">Mutuality</option>
                    <option value="p_proximity">Proximity</option>
                    <option value="name">Name</option>

                </select>
            </form>
        </div>
        Mutuality Raking:
        <div id ="scale_ref" >
        </div>
        Top Partners:
        <div id ="export_aster_plot">
        </div>
    </div>
</div>

<script>

    /////////////////////////////////
    //// Apply Filters
    /////////////////////////////////

    var div = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

    var oldNodeData, nodesOld, oldPie, oldPieData;

    //Update Data due to filters
    function UpdateFilters() {
        countrySortingVal = countrySortingE.options[countrySortingE.selectedIndex].value;
        asterSortingVal = asterSortingE.options[asterSortingE.selectedIndex].value;
        continentSortingVal = d3.select("input[value=\"continent_sorting_val\"]").node().checked;
        CompleteForce();
    }

    //Part 2: Multi-Force
    function CompleteForce() {
        //Init graph links

        graph.nodes = restructuredData[yearIndex];
        graph.links = [];
        graph.nodes.forEach(function (d, i) {
            graph.nodes.forEach(function (e, j) {
                d.top_partners.forEach(function (partner) {
                    if (partner.country_id == e.country_id) {
                        graph.links.push({"source": i, "target": j})
                    }
                });
            });
        });

        //Link Nodes and links to force
        force.nodes(graph.nodes)
                .links(graph.links)
                .size([svg_width, svg_height])
                .start();
        //Dont apply layout
        force.stop();
    }


    //Reformat Data since nested (multi-year)
    function CalculateRestructuredData(data) {
        var restructuredData = [];
        for (var i = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].years.length; j++) {

                if (i==0) {
                    restructuredData[j] = new Array();
                    var currentYear = data[i].years[j].year;

                    //Update min/max years in data
                    minYear = (currentYear < minYear) ? currentYear : minYear;
                    maxYear = (currentYear > maxYear) ? currentYear : maxYear;
                }

                restructuredData[j].push(
                        {
                            'name': data[i].name,
                            'continent': data[i].continent,
                            'gdp': data[i].years[j].gdp,
                            'life_expectancy': data[i].years[j].life_expectancy,
                            'population': data[i].years[j].population,
                            'year': currentYear,
                            'longitude': data[i].longitude,
                            'latitude':data[i].latitude,
                            'country_id':data[i].country_id,
                            'top_partners':data[i].years[j].top_partners,
                            'year':data[i].years[j].year
                        });
            }
        }
        return restructuredData;
    }

    var intransition = false;

    var dropdowns = d3.selectAll("select");
    dropdowns.on("change", function() {
        UpdateFilters();
        ConstructPieLayout();
        ConstructAsterLayout();
        BuildComponents();
        UpdateViz();

    });

    var countrySortingE = document.getElementById("country_sorting_val");
    var countrySortingVal = countrySortingE.options[countrySortingE.selectedIndex].value;
    var countrySortingValPrev = countrySortingVal;

    var asterSortingE = document.getElementById("aster_sorting_val");
    var asterSortingVal = asterSortingE.options[asterSortingE.selectedIndex].value;

    var continentSortingVal = d3.select("input[value=\"continent_sorting_val\"]").node().checked;
    var continentSortingValPrev = continentSortingVal;


    var screen_width = 1293;
    var screen_height = 710;
    var svg_width = screen_width * .75;
    var svg_height = screen_height * .95;
    var svgX_offset = 0;
    var svgY_offset = 20;
    var svg_cx = svg_width/2 + svgX_offset;
    var svg_cy = svg_height/2 + svgY_offset;

    //Grouping Reference
    var svg = d3.select("#bottom_left_panel").append("svg")
            .attr("width", svg_width)
            .attr("height", svg_height)
            .attr("transform", "translate(" + svg_width/2 + "," + svg_height/2 + ")");

    //Group Ref in order of drawing
    var g_border = svg.append("g").attr("class", "border");
    var g_chords = svg.append("g").attr("class", "chords");
    var g_nodes = svg.append("g").attr("class", "nodes");
    var g_labels = svg.append("g").attr("class", "labels");

    var aster_offset = 25;
    var aster_width = 300;
    var aster_height = 300;
    var asterYOffset = 0;
    var aster_radius = Math.min(aster_width, aster_height) / 2;
    var aster_innerRadius = 0.5 * aster_radius;
    var total_exportSum;
    var svg_aster = d3.select("#export_aster_plot").append("svg")
            .attr("width", aster_width)
            .attr("height", aster_height)
            .append("g")
            .attr("transform", "translate(" + aster_width / 2 + "," + (aster_height/2 + asterYOffset) + ")");

    var innerSlices, outerSlices, aster_arc, aster_data, aster_outlineArc
    var aster_partner_info_percent;
    var aster_partner_info_name;
    var aster_partner_info_mutual;
    var aster_partner_info_export;
    var aster_partner_info_prox;
    var currentSliceIndex = 0;

    //Data Holders
    var graph = {nodes: [], links: []};
    var restructuredData;
    var continentListing;

    //Label Loc offset
    var padTextX = 22;
    var padTextY = 4;

    //////////////////////////////////////
    // Graph Init layouts
    //////////////////////////////////////
    // Force layout
    var link;
    var force = d3.layout.force()
            .charge(-50)
            .linkDistance(10)
            .linkStrength(0);
    // Pie Layout
    var r, arc, pie, arc_outer, pieData;
    var R_FACTOR = 1.45;
    // DOM
    var nodes, circs, labels, paths, links, chords;

    var startUp = true;
    var selectedCountry = "United States";
    document.getElementById('current_country').innerHTML = selectedCountry;

    var mutualScale = d3.scale.linear()
            .domain([9, 4.5, 0])
            .range(["green", "blue", "red"]);

    var continentColorScale = d3.scale.category10();

    var timeSlider = document.getElementById("slider-time");
    var yearIndex = timeSlider.value - timeSlider.min;

    //Apply Input Interaction
//    var inputs = d3.selectAll("input");
    d3.select("input[id=\"slider-time\"]").on("input", function() {

        console.log(true);

        yearIndex = timeSlider.value - timeSlider.min;

        UpdateFilters();
        ConstructPieLayout();
        ConstructAsterLayout();
        BuildComponents();
        UpdateViz();
    });


    d3.select("input[value=\"continent_sorting_val\"]").on("change", function() {

        yearIndex = timeSlider.value - timeSlider.min;

        UpdateFilters();
        ConstructPieLayout();
        ConstructAsterLayout();
        BuildComponents();
        UpdateViz();
    });


    //Add Legend
    // add legend

    function AddLegend() {

        var initX = 50;
        var offsetX = 25;
        var offsetText = 22;
        var offsetBox = 10;
        var spacing = 25;

        var legend = d3.select("#continents_sorting_container").append("svg").append("g")
            .attr("class", "legend")
            .attr("height", 100)
            .attr("width", 100);

        legend.selectAll('g').data(continentListing)
                .enter()
                .append('g')
                .each(function (d, i) {
                    var g = d3.select(this);
                    g.append("rect")
                            .attr("x", initX)
                            .attr("y", i * spacing + offsetBox)
                            .attr("width", 10)
                            .attr("height", 10)
                            .style("fill", continentColorScale(i));

                    g.append("text")
                            .attr("x", initX + offsetX)
                            .attr("y", i * spacing + offsetText)
                            .attr("height", 30)
                            .attr("width", 100)
                            .style("fill", continentColorScale(i))
                            .text(d.continent);

                });
    }

    function AddPartnerScale() {

        var data = d3.range(2);

        var scale_svg = d3.select("#scale_ref").append("svg").attr("height", 50);

        var minX = 25;
        var maxX = 175;

        var gradient = scale_svg
                .append("linearGradient")
                .attr("x1", minX)
                .attr("x2", maxX)
                .attr("y1", "0")
                .attr("y2", "0")
                .attr("id", "gradient")
                .attr("gradientUnits", "userSpaceOnUse")

        gradient
                .append("stop")
                .attr("offset", "0")
                .attr("stop-color", "#0f0")

        gradient
                .append("stop")
                .attr("offset", "0.5")
                .attr("stop-color", "#00f")

        gradient
                .append("stop")
                .attr("offset", "1")
                .attr("stop-color", "#f00")



        scale_svg
                .selectAll("rect")
                .data([0])
                .enter()
                .append("rect")
                .attr("x", function(d,i){
                    return 25;
                })
                .attr("y", 25)
                .attr("width", 150)
                .attr("height", function(d){return 20})
                .attr("fill", "url(#gradient)");

        scale_svg
                .selectAll("text")
                .data(["Positive","Neutral", "Negative"])
                .enter()
                .append("text")
                .attr("x", function(d,i){
                    return i*75 + 25;
                })
                .attr("y", 20)
                .attr("width", 30)
                .attr("height", function(d){return 80})
                .text( function(d){
                    return d;
                })
                .attr("text-anchor", function(d,i){
                    return "middle";
                })
                .attr("font-family", "sans-serif")
                .attr("font-size", "10px")
                .attr("fill", "black")

        scale_svg
                .append("rect")
                .attr("x", function(d){return 250;})
                .attr("y", 25)
                .attr("width", 25)
                .attr("height", function(d){return 20})
                .attr("fill", "grey");

        scale_svg
                .append("text")
                .attr("x", 250)
                .attr("y", 20)
                .attr("width", 30)
                .attr("height", 80)
                .text( "None")
                .attr("text-anchor", function(d,i){
                    return "right";
                })
                .attr("font-family", "sans-serif")
                .attr("font-size", "10px")
                .attr("fill", "black");




    }


    //////////////////////////////////////
    // Read In Data
    //////////////////////////////////////
    d3.json( "data/countries_1995_2012.json", function(error, data) {
        //Calculate year range
        restructuredData = CalculateRestructuredData(data);     //New Data
        continentListing = NumberCountriesPerContinent(data);
        AddLegend();
        AddPartnerScale();

        UpdateFilters();
        ConstructPieLayout();
        ConstructAsterLayout();
        BuildComponents();
        UpdateViz();
    });


    function BuildComponents(){

        AddChords();
        AddNodes();
        AddLabels();
        AddSlices();


        chords.exit().remove();
        nodes.exit().remove();
        labels.exit().remove();
    }

    function AddChords(){

        chords = g_chords.selectAll("path")
                .data( graph.links );

        chords.enter()
                .append("path")
                .attr("class", "chord")
                .attr("name", function(d){
                    return d.source.name + "---" + d.target.name;
                })
                .attr("stroke", "black")
                .attr("fill", "grey")
                .attr("opacity", 1);
    }

    function AddNodes(){

        nodes = g_nodes.selectAll("circle")
                .data(pieData);

        nodes.enter()
                .append("circle")
                .attr("class", "node")
                .attr("name", function(d){
                    return d.name;
                })
                .attr("r", 6)
                .attr("transform", function(d) {
                        return "translate(" + svg_cx + "," + svg_cy + ")";
                })
                .on("mouseover", mouseOverEvent)
                .on("mouseout", mouseOutEvent);
    }

    function AddLabels(){
        labels = g_labels.selectAll("text")
                .data( pieData );

        labels.enter()
                .append("text")
                .attr("class", "node")
                .attr("name", function(d){
                    return d.name;
                })
                .text(function (d) {  return d.name;  })
                .attr("text-anchor", "left")
                .attr("x", function (d) { return 0; })
                .attr("y", function (d) { return 0; })
                .attr("transform", function(d) {
                    return "translate(" + (svg_cx) + "," + (svg_cy) + ")rotate(" + 0 + ")";
                })
                .attr("font-family", "sans-serif")
                .attr("font-size", "10px")
                .attr("fill", "black")
                .on("mouseover", mouseOverEvent)
                .on("mouseout", mouseOutEvent);

    }


    function AddAsterInfo(partner){

        aster_partner_info_percent = svg_aster.selectAll(".partnerPercent")
                .data([partner]);

        aster_partner_info_percent
                .enter()
                .append("text")
                .attr("class", "partnerPercent")
//                .attr("dy", ".35em")
                .attr("x", 0)
                .attr("y", -35)
                .attr("text-anchor", "middle") // text-align: right
                .attr("font-family", "sans-serif")
                .attr("font-size", "28px")
                .attr("fill", "black")

        aster_partner_info_name = svg_aster.selectAll(".partnerName")
                .data([partner]);

        aster_partner_info_name
                .enter()
                .append("text")
                .attr("class", "partnerName")
//                .attr("dy", ".35em")
                .attr("x", 0)
                .attr("y", 10)
                .attr("text-anchor", "middle") // text-align: right
                .text(function(d){
                    return d.partner.name;
                });

        aster_partner_info_mutual = svg_aster.selectAll(".partnerAttr1")
                .data([partner]);

        aster_partner_info_mutual
                .enter()
                .append("text")
                .attr("class", "partnerAttr1")
//                .attr("dy", ".35em")
                .attr("x", 0)
                .attr("y", 60)
                .attr("text-anchor", "middle") // text-align: right
                .text(function(d){
                    (d.p_mutuality) < 0 ? "None" : 10-d.p_mutuality;
                })
                .attr("font-family", "sans-serif")
                .attr("font-size", "20px")
                .attr("fill", "black")

        aster_partner_info_export = svg_aster.selectAll(".partnerAttr2")
                .data([partner]);

        aster_partner_info_export
                .enter()
                .append("text")
                .attr("class", "partnerAttr2")
//                .attr("dy", ".35em")
                .attr("x", 0)
                .attr("y", -15)
                .attr("text-anchor", "middle") // text-align: right
                .attr("fill", "#616161")

        aster_partner_info_prox = svg_aster.selectAll(".partnerAttr3")
                .data([partner]);

        aster_partner_info_prox
                .enter()
                .append("text")
                .attr("class", "partnerAttr3")
//                .attr("dy", ".35em")
                .attr("x", 0)
                .attr("y", 35)
                .attr("text-anchor", "middle") // text-align: right
                .text(function(d){
                    return d.p_proximity;
                })
                .attr("fill", "#616161")


        aster_partner_info_percent.exit().remove();
        aster_partner_info_name.exit().remove();
        aster_partner_info_mutual.exit().remove();
        aster_partner_info_export.exit().remove();
        aster_partner_info_prox.exit().remove();
    }

    function UpdateAsterInfo(){
        aster_partner_info_percent.text(function(d){
            return d3.round(d.percentExport*100,1) + "%";
        });
        aster_partner_info_name.text(function(d){       return d.partner.name;  });
        aster_partner_info_mutual
                .text(function(d){
                    return (d.p_mutuality) < 0 ? "None" : 10-d.p_mutuality;
                })
                .attr("fill", function(d){
                    return (d.p_mutuality >= 0) ? mutualScale(d.p_mutuality) : "black";
                });
        aster_partner_info_export.text(function(d){     return "Amount: " + d3.round(d.p_total_export / 1e6, 1) + "M";   });
        aster_partner_info_prox.text(function(d){       return "Proximity: " + d3.format(".1f")(d3.round(d.p_proximity,1)) + "º";   });

    }


    function HighlightSlice(d){

//        var currentSlice;
//
//        aster_data.sort(compareAsterNew2).filter( function(e,j){
//            if (e.data.partner.name == d.data.partner.name){
//                currentSliceIndex = j;
//                return j;
//            }
//        })



        outerSlices
            .filter( function(e,j){
                return e.data.partner.name == d.data.partner.name;
            })
            .classed("selectSlice", true);

        outerSlices
            .filter( function(e,j){
                return e.data.partner.name != d.data.partner.name;
            })
            .classed("selectSlice", false);
    }

    function AddSlices(){

        outerSlices = svg_aster.selectAll(".outlineArc")
                .data(aster_data);

        outerSlices
                .enter()
                .append("path")
                .attr("fill", "silver")
                .attr("stroke", "gray")
                .attr("class", "outlineArc")
                .attr("d", aster_outlineArc)
                .on("mouseover", function(d,i) {

                    aster_data.sort(compareAsterNew2).filter( function(e,j){
                        if (e.data.partner.name == d.data.partner.name){
                            currentSliceIndex = j;
                            return j;
                        }
                    })

                    ShowPartnerChords(d.data.partner);
                    aster_update(d);
                })
                .on("mouseout", function(d,i) {
                    div.transition()
                            .duration(500)
                            .style("opacity", 0);
                    UpdateChords(0);
                    HighlightSlice(d);

                });

        innerSlices = svg_aster.selectAll(".solidArc")
                .data(aster_data);

        innerSlices
                .enter()
                .append("path")
                .attr("fill", function(d,i) {
//                    console.log(i);
                    var nullColor = "grey";
                    var ranking = GetMutualRanking(d.data.source, d.data.partner);
                    return (ranking >= 0) ? mutualScale(ranking) : nullColor;
                })
                .attr("class", "solidArc")
                .attr("stroke", "black")
                .attr("d", aster_arc)
                .on("mouseover", function(d,i) {

                    aster_data.sort(compareAsterNew2).filter( function(e,j){
                        if (e.data.partner.name == d.data.partner.name){
                            currentSliceIndex = j;
                            return j;
                        }
                    })

                    ShowPartnerChords(d.data.partner);
                    aster_update(d);
                })
                .on("mouseout", function(d,i) {
                    div.transition()
                            .duration(500)
                            .style("opacity", 0);
                    UpdateChords(0);
                    HighlightSlice(d);

                });


        outerSlices.exit().remove();
        innerSlices.exit().remove();

    }

    function ShowPartnerChords(partner){
        chords.transition()
                .delay(0)
                .duration(0)
                .attr("d", function (d) {
                    if (d.source.name == partner.name) {
                        return DrawPath(d.source, d.target);
                    }
                    if (d.source.name == selectedCountry) {
                        return DrawPath(d.source, d.target);
                    }
                })
                .attr("stroke", "black")
                .attr("fill", function (d,i) {
                    var nullColor = "grey";
                    if (d.source.name == partner.name) {
                        var ranking = GetMutualRanking(d.source, d.target);
                        return (ranking >= 0) ? mutualScale(ranking) : nullColor;
                    }
                    if (d.source.name == selectedCountry) {
                        var ranking = GetMutualRanking(d.source, d.target);
                        return (ranking >= 0) ? mutualScale(ranking) : nullColor;
                    }
                    return nullColor;
                })
                .attr("opacity", function(d){
                    var directedLink =  (d.source.name == selectedCountry && d.target.name == partner.name );
                    return (directedLink) ? 1 : 0.25;
                });

    }


    function ConstructAsterLayout() {

        var currentTopPartners = []
        graph.links.filter(function (d) {
            if (d.source.name == selectedCountry) {
                d.source.top_partners.forEach( function(e,i) {
                    if (e.country_id == d.target.country_id) {
                        currentTopPartners.push({
                            "source": d.source,
                            "partner": d.target,
                            "p_total_export": GetTotalExport(e),
                            "p_proximity" : GetProximity(d.source, d.target),
                            "p_mutuality" : GetMutualRanking(d.source, d.target),
                        });
                    }
                })
            }
        });

        total_exportSum = 0;
        currentTopPartners.forEach( function(d){
            total_exportSum = total_exportSum + d.p_total_export;
        });

        currentTopPartners.forEach( function(d){
            d.total_exportSum = total_exportSum;
        });

        var aster_pie = d3.layout.pie()
                .sort( compareAsterNew )
                .value(function(d) { return 1; });

        aster_arc = d3.svg.arc()
                .innerRadius(aster_innerRadius)
                .outerRadius(function (d,i) {
                    var minR = (aster_innerRadius + aster_offset);
                    var percentExport = (d.data.p_total_export/ d.data.total_exportSum);
                    d.data.percentExport = percentExport;
                    return (aster_radius - minR) * percentExport + minR;
                });

        aster_outlineArc = d3.svg.arc()
                .innerRadius(aster_innerRadius)
                .outerRadius(aster_radius);


        aster_data = aster_pie( currentTopPartners );

    }


    //Part 2: Circular
    function ConstructPieLayout() {

        r = .5*Math.min(svg_height, svg_width)/R_FACTOR;

        arc = d3.svg.arc()
                .outerRadius(r);

        pie = d3.layout.pie()
                .sort(compareCountries) // Sorting by categories
                .value(function(d, i) {
                    return 1;  // We want an equal pie share/slice for each point
                });

        pieData = pie(graph.nodes).map(function (d, i) {

            // Needed to caclulate the centroid
            d.innerRadius = 0;
            d.outerRadius = r;

            d.data.startAngle = d.startAngle;
            d.data.endAngle = d.endAngle;

            d.data.x = arc.centroid(d)[0]*2.0 + svg_cx;
            d.data.y = arc.centroid(d)[1]*2.0 + svg_cy;

            return d.data;
        });

        ConstructContinentPieLayout();
    }

    //Part 2: Circular
    function ConstructContinentPieLayout() {

        var r1 = .5*Math.min(svg_height, svg_width)/R_FACTOR;

        var arc1 = d3.svg.arc()
                .innerRadius(r1)
                .outerRadius(r1+padTextX);

        var pie1 = d3.layout.pie()
                .sort( function(a,b){
                    return d3.ascending(a["continent"], b["continent"]);
                })
                .value(function(d, i) {
                    return d.value;
                });

        var p = pie1( (continentSortingVal) ? continentListing : [{value: 1}]);

        var myPath = g_border.selectAll("path").data(p);

        myPath.enter()
                .append("path");
        myPath
                .attr("fill", function(d,i) {
                    console.log( continentSortingVal);
                    return (continentSortingVal) ? continentColorScale(i) : "silver";
                })
                .attr("class", "path")
                .attr("stroke", "black")
                .attr("d", function(d){
                    return arc1(d);
                })
                .attr("transform", function(d){
                    return "translate(" + svg_cx + "," + svg_cy + ")";
                })

        myPath.exit().remove();

    };

    function UpdateViz(){
        graph_update();
        if (startUp) { startUp = false; }
    }

    function UpdateChords(transTime){

        chords.transition()
                .delay(0)
                .duration(transTime)
                .attr("d", function (d) {
                    if (d.source.name == selectedCountry) {
                        return DrawPath(d.source, d.target);
                    }
                })
                .attr("stroke", "black")
                .attr("fill", function (d) {
                    var nullColor = "grey";
                    if (d.source.name == selectedCountry) {
                        var ranking = GetMutualRanking(d.source, d.target);
                        return (ranking >= 0) ? mutualScale(ranking) : nullColor;
                    }
                    else{
                        return nullColor
                    }
                })
                .attr("opacity", 1);
    }

    function UpdateNodes(transTime){

        nodes.transition()
                .delay(0)
                .duration(transTime)
                .each("start", function(d) {
                    intransition = true;
                })
                .attrTween("transform", function(d, i, a) {
                    var oldCoords = d3.transform(d3.select(this).attr("transform")).translate;
                    return ParameterizeNode(oldCoords, [d.x, d.y]);
                })
                .each("end", function(d) {
                    intransition = false;
                })

        nodes.classed("node--source", function(d){
            return d.name == selectedCountry;
        });
    }

    function UpdateLabels(transTime) {

        labels.transition()
                .delay(0)
                .duration(transTime)
                .each("start", function (d) {

                    var oldRotate = d3.transform(d3.select(this).attr("transform")).rotate;
                    var oldCoords = d3.transform(d3.select(this).attr("transform")).translate;

                    var leftHem = oldCoords[0] <= svg_cx + padTextY ? true : false;
                    var tx = (leftHem) ? oldRotate + 180 : oldRotate;
                    var ty = (leftHem) ? 2 * padTextY : 0;

                    d3.select(this).attr("transform", function (d) {
                        return "translate(" + oldCoords[0] + "," + oldCoords[1] + ")rotate(" + tx + ")translate(" + 0 + "," + ty + ")";
                    });
                    d3.select(this).attr("text-anchor", function (d) {
                        return "start";

                    });
                })
                .attrTween("transform", function (d, i, a) {
                    var oldCoords = d3.transform(d3.select(this).attr("transform")).translate;
                    var oldRotate = d3.transform(d3.select(this).attr("transform")).rotate;
                    return ParameterizeLabel(oldCoords, d, [padTextX, padTextY], oldRotate);

                })
                .each("end", function (d) {
                    var shift = angle(d, 0, 0) < 0 ? 1.0 : -1.0;
                    d3.select(this).attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y +
                                ")rotate(" + angle(d, -90, 90) +
                                ")translate(" + shift * padTextX + "," + padTextY + ")";
                    });
                    d3.select(this).attr("text-anchor", function (d) {
                        return angle(d, 0, 0) < 0 ? "start" : "end";

                    });
                });
    }


    function UpdateSlices(){

        outerSlices
                .attr("fill", "silver")
                .attr("stroke", "black")
                .attr("class", "outlineArc")
                .attr("d", aster_outlineArc)
//                .on("mouseover", function(d) {
////                    div.transition()
////                            .duration(200)
////                            .style("opacity", .9);
////                    div .html(d.data.partner.name + "<br/>"  + d.data.p_proximity)
////                            .style("left", (d3.event.pageX) + "px")
////                            .style("top", (d3.event.pageY - 28) + "px");
//                    console.log(true);
//                    ShowPartnerChords(d.data.partner);
//                    AddAsterInfo(d.data);
//                    UpdateAsterInfo();
//                })
//                .on("mouseout", function(d) {
//                    console.log(false);
//                    div.transition()
//                            .duration(500)
//                            .style("opacity", 0);
//                    UpdateChords(0);
//
//                });

        innerSlices
                .attr("fill", function(d,i) {
                    var nullColor = "grey";
//                    if (d.data.source.name == selectedCountry) {
                    var ranking = d.data.p_mutuality;
                    return (ranking >= 0) ? mutualScale(ranking) : nullColor;
//                    return "red";
                })
                .attr("class", "solidArc")
                .attr("stroke", "black")
                .attr("d", aster_arc);
//            .on('mouseover', tip.show)
//            .on('mouseout', tip.hide);


        console.log(outerSlices.data());

        var currentSlice = outerSlices.sort(compareAsterNew2).data()[currentSliceIndex];
        aster_update(currentSlice);

    }


    function aster_update(current){
        AddAsterInfo(current.data);
        UpdateAsterInfo();
        HighlightSlice(current);
    }


    function graph_update(){

        var transTime = 0;
        if (countrySortingValPrev != countrySortingVal){
            transTime = 1000;
            countrySortingValPrev = countrySortingVal;
        }
        if (continentSortingValPrev != continentSortingVal){
            transTime = 1000;
            continentSortingValPrev = continentSortingVal;
        }

        UpdateChords(transTime);
        UpdateNodes(transTime);
        UpdateLabels(transTime);
        UpdateSlices();

    }

    //////////////////////////////////////
    // Country Sorting
    //////////////////////////////////////
    //Sorting functions (New or cached sorting value)
    //Sorting functions (New or cached sorting value)
    function compareCountriesNew(a, b){
        if (countrySortingVal == "name") {          return d3.ascending(a["name"], b["name"]); }
        if (countrySortingVal == "population") {    return b["population"] - a["population"]; }
        if (countrySortingVal == "gdp") {           return b["gdp"] - a["gdp"]; }
    }

    function compareCountries(a, b) {
        if (continentSortingVal) {
            var ans = d3.ascending(a["continent"], b["continent"]);
            return (ans != 0) ? ans : compareCountriesNew(a,b);
        }
        else{
            return compareCountriesNew(a,b);
        }
    }

    function compareContinents(a, b) {
        if (continentSortingVal) {
            return b.number - a.number;
        }
        else{
            return null;
        }
    }

    function compareAsterNew(a, b){
        if (asterSortingVal == "p_total_export") {  return b.p_total_export - a.p_total_export; }
        if (asterSortingVal == "p_proximity") {       return a.p_proximity - b.p_proximity; }
        if (asterSortingVal == "p_mutuality") {       return b.p_mutuality - a.p_mutuality; }
        if (asterSortingVal == "name") {       return d3.ascending(a.partner.name, b.partner.name);  }
    }

    function compareAsterNew2(a, b){
        if (asterSortingVal == "p_total_export") {  return b.data.p_total_export - a.data.p_total_export; }
        if (asterSortingVal == "p_proximity") {       return a.data.p_proximity - b.data.p_proximity; }
        if (asterSortingVal == "p_mutuality") {       return b.data.p_mutuality - a.data.p_mutuality; }
        if (asterSortingVal == "name") {       return d3.ascending(a.data.partner.name, b.data.partner.name);  }
    }


    function mouseOverUpdateComponents(){
        UpdateChords(0);
        ConstructAsterLayout();
        AddSlices();
        UpdateSlices();
    }

    //////////////////////////////////////
    // Mouse Events
    //////////////////////////////////////
    function mouseOverEvent(d){

        if (!intransition) {
            selectedCountry = d.name;
            document.getElementById('current_country').innerHTML = selectedCountry;

            nodes.each(function (n) {
                n.target = false;
                n.source = false;
            })
            nodes.classed("hidden", false);

            chords
                    .classed("chord--source", function (l) {
                        if (l.source === d) {
                            l.source.source = true;
                            return l.target.target = true;
                        }
                    });

            mouseOverUpdateComponents();

            nodes
                    .classed("node--target", function (n) { return n.target;    })
                    .classed("node--source", function (n) { return n.source;    })
                    .classed("hidden", function (n) {   return !(n.target || n.source); });
            labels
                    .classed("hidden", function (n) {   return !(n.target || n.source); });

        }
    }

    function mouseOutEvent(d){
        chords.classed("link--target", false).classed("link--source", false);
        nodes.classed("node--target", false).classed("hidden", false);
        labels.classed("hidden", false);
    }

    //////////////////////////////////////
    // Country Rankings
    //////////////////////////////////////
    function GetMutualRanking(sourceExporter, targetExporter){
        var val = -1
        var MAX_PARTNERS = 10;
        targetExporter.top_partners.forEach(function (partner, i) {
            if (partner.country_id == sourceExporter.country_id) {
                val = (MAX_PARTNERS-1)-i;   //indexed
            }
        })
        return val;
    }

    function GetProximity(sourceExporter, targetExporter){
        var dx = targetExporter.latitude - sourceExporter.latitude;
        var dy = targetExporter.longitude - sourceExporter.longitude;
        var dist = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
        return dist
    }

    function GetTotalExport(partnerExporter){
        return partnerExporter.total_export;
    }

    //////////////////////////////////////
    // Math Helpers
    //////////////////////////////////////
    // Updated Angle Calculation Function...
    function angle(d, offset, threshold) {
        //var theta = Math.atan2(d.y - svg_height/2, d.x - svg_width/2) * 180 / Math.PI;
        var a = (d.startAngle + d.endAngle) * 90 / Math.PI + offset;
        return a > threshold ? a - 180 : a;
    }

    function Polar2Cartesian(theta, radius){

        var x_coord = radius * Math.cos(theta - Math.PI/2.0) + svg_cx;
        var y_coord = radius * Math.sin(theta - Math.PI/2.0) + svg_cy;
        return {"x" : x_coord, "y" : y_coord};
    }

    function DrawPath(source, target) {
        var p = "M" + Polar2Cartesian( source.startAngle, r).x + "," + Polar2Cartesian( source.startAngle, r).y +
                "C" + svg_cx                                   + " " + svg_cy                                   +
                " " + svg_cx                                   + " " + svg_cy                                   +
                " " + Polar2Cartesian( target.startAngle, r).x + " " + Polar2Cartesian( target.startAngle, r).y +
                "L" + Polar2Cartesian( target.endAngle, r).x   + "," + Polar2Cartesian( target.endAngle, r).y   +
                "C" + svg_cx                                   + " " + svg_cy                                   +
                " " + svg_cx                                   + " " + svg_cy                                   +
                " " + Polar2Cartesian( source.endAngle,r).x    + " " + Polar2Cartesian( source.endAngle, r).y   +
                "L" + Polar2Cartesian( source.startAngle,r).x  + "," + Polar2Cartesian( source.startAngle, r).y +
                "Z";
        return p;
    }

//    function ParameterizeChord(old_source, old_target, source, target) {
//        return function (t) {
//
//            var s1 = ParameterizePoint(
//                    [old_source[0], old_source[1]],
//                    [Polar2Cartesian(source.startAngle, r).x, Polar2Cartesian(source.startAngle, r).y],
//                    t
//            );
//
//            var s2 = ParameterizePoint(
//                    [old_target[0], old_target[1]],
//                    [Polar2Cartesian(target.startAngle, r).x, Polar2Cartesian(target.startAngle, r).y],
//                    t
//            );
//            var s3 = ParameterizePoint(
//                    [old_target[0], old_target[1]],
//                    [Polar2Cartesian(target.endAngle, r).x, Polar2Cartesian(target.endAngle, r).y],
//                    t
//            );
//            var s4 = ParameterizePoint(
//                    [old_source[0], old_source[1]],
//                    [Polar2Cartesian(source.endAngle, r).x, Polar2Cartesian(source.endAngle, r).y],
//                    t
//            );
//
//            return DrawPath(source, target);
//
//        }
//    }

    function ParameterizeNode(old_d, new_d) {
        return function (t) {

            var theta1 = Math.atan2(old_d[1] - svg_cy, old_d[0] - svg_cx);
            var theta2 = Math.atan2(new_d[1] - svg_cy, new_d[0] - svg_cx);
            var delta = theta2 - theta1;

            var dx = r * Math.cos(theta1 + delta * t) + svg_cx;
            var dy = r * Math.sin(theta1 + delta * t) + svg_cy;

            return "translate(" + (dx) + "," + (dy) + ")";
        }
    }

//    function ParameterizePoint(old_d, new_d, t) {
//
//            var theta1 = Math.atan2(old_d[1] - svg_cy, old_d[0] - svg_cx);
//            var theta2 = Math.atan2(new_d[1] - svg_cy, new_d[0] - svg_cx);
//            var delta = theta2 - theta1;
//
//            var dx = r * Math.cos(theta1 + delta * t) + svg_cx;
//            var dy = r * Math.sin(theta1 + delta * t) + svg_cy;
//
//            return [ dx , dy ];
//    }

    function ParameterizeLabel(old_d, d, offset_d, old_rotate) {
        return function (t) {

            //Label Orientation - if on left hemisphere
            var wasFlipLabel = old_d[0] < svg_cx + padTextY ? true : false;
            var shouldFlipLabel = d.x < svg_cx + padTextY ? true : false;

            //Label adjustments
            var a = (!wasFlipLabel) ? angle(d, -90, 90) : angle(d, -90, 90) - 180;
            if (wasFlipLabel != shouldFlipLabel){
                a = (shouldFlipLabel) ? a - 180 : a + 180;
            }
            if (a < 0 && a <-180){  a = 360 + a; }

            //Angle Diffs
            var theta1 = Math.atan2(old_d[1] - svg_cy, old_d[0] - svg_cx);
            var theta2 = Math.atan2(d.y - svg_cy, d.x - svg_cx);
            var delta = theta2 - theta1;
            var deltaR = (a - old_rotate);

            //Ignore Small changes
            var rad_diff = delta / (Math.PI * 2);
            if ((Math.abs(rad_diff) < .003 || Math.abs(rad_diff) > .98)){
                t=1;        //Dont paramterize, just go to final value
            }

            var dx_t = r * Math.cos(theta1 + delta * t) + svg_cx;// + offset_d[0];
            var dy_t = r * Math.sin(theta1 + delta * t) + svg_cy;// + offset_d[1];
            var dr = (old_rotate + deltaR*t);

            return "translate(" + dx_t + "," + dy_t + ")rotate(" + dr + ")translate(" + offset_d[0] + "," + offset_d[1] + ")";

        }
    }

    function NumberCountriesPerContinent(data) {
        var continentListing = d3.nest()           //Aggregated
                .key(function (d) {
                    return d.continent
                })
                .rollup(function (d) {
                    return {"sumCountries" : d3.sum( d, function(g){ return 1; } ) };
                }).entries(data);

        continentListing.forEach(function(d){      //Rename variables
            d.continent = d.key;
            d.value = d.values.sumCountries;
        });
        return continentListing;
    }



</script>
</body>
</html>