<!DOCTYPE html>
<meta charset="utf-8">
<title>Homework 2 Graph</title>
<style>

    .slider-width{
        width: 440px;
        vertical-align: top;
        position: relative;
        top: -3px;
    }

    .interactive{
        width:120px;
        float: left;
    }

    .chord {
        stroke: black;
        /*stroke-width: .8px;*/
        /*stroke-opacity: .4;*/
    }

    .node{
        fill: white;
        stroke: #000;
        stroke-width: .9px;
    }

    .node--source {
        fill: black;
    }

    .node--target{
        fill: black;
    }

    .chord--source{
        stroke: black;
        stroke-opacity: 1;
    }

    .hidden{
        opacity: .4;
        stroke-opacity: .4;
    }


    #container_main {height: 710px; width:1293px; font-size:0;}
    #left_panel, #right_panel {display: inline-block; *display: inline; zoom: 1; vertical-align: top; font-size: 16px;}
    #left_panel {height: 100%; width: 75%; background: white;}
    #right_panel {height: 100%; width: 25%; background: white;}
    #top_left_panel {height: 5%; width: 100%; background: white;}
    #bottom_left_panel {height: 95%; width: 100%; background: white;}

</style>
<body>
<!--<script src="http://d3js.org/d3.v3.min.js"></script>-->
<script src="src/d3.v3.min.js"></script>

<div id="container_main">
    <div id="left_panel">
        <div id="top_left_panel">
            <!--Select Year-->
            <label >
                <label class = interactive>Year:</label>
                <label id="minYear">1995 </label>
                <input class="slider-width" type="range" name="points" width = "300" min="1995" max="2012" step="1" value="0" id="slider-time" oninput=";">
                <label id="maxYear">2012</label>
            </label>
        </div>
        <!--SVG Main-->
        <div id="bottom_left_panel">
        </div>
    </div>
    <!--Legend & Select Attributes Panel-->
    <div id="right_panel">
        <form>
            <label><input onchange="" type="checkbox" name="continent_sorting_val" value="continent_sorting_val"> Combine Like Continents</label>
        </form>
        <div>
            <form>
                Top Partner Sorting:
                <select id="aster_sorting_val" onchange="" name="aster_sorting_val">
                    <option value="export_ranking" selected="selected">Export Amount</option>
                    <option value="mutuality">Mutuality</option>
                    <option value="proximity">Proximity</option>

                </select>
            </form>
            <form>
                Country Sorting:
                <select id="country_sorting_val" onchange="" name="country_sorting_val">
                    <option value="name" selected="selected">Name</option>
                    <option value="population">Population</option>
                    <option value="gdp">GDP</option>
                </select>
            </form>
        </div>
    </div>
</div>

<script>

    /////////////////////////////////
    //// Apply Filters
    /////////////////////////////////

    var oldNodeData, nodesOld, oldPie, oldPieData;

    //Update Data due to filters
    function UpdateFilters() {
        countrySortingVal = countrySortingE.options[countrySortingE.selectedIndex].value;
        asterSortingVal = asterSortingE.options[asterSortingE.selectedIndex].value;
        continentSortingVal = d3.select("input[value=\"continent_sorting_val\"]").node().checked;
        CompleteForce();
    }

    //Part 2: Multi-Force
    function CompleteForce() {
        //Init graph links

        graph.nodes = restructuredData[yearIndex];
        graph.links = [];
        graph.nodes.forEach(function (d, i) {
            graph.nodes.forEach(function (e, j) {
                d.top_partners.forEach(function (partner) {
                    if (partner.country_id == e.country_id) {
                        graph.links.push({"source": i, "target": j})
                    }
                });
            });
        });

        //Link Nodes and links to force
        force.nodes(graph.nodes)
                .links(graph.links)
                .size([svg_width, svg_height])
                .start();
        //Dont apply layout
        force.stop();
    }


    //Reformat Data since nested (multi-year)
    function CalculateRestructuredData(data) {
        var restructuredData = [];
        for (var i = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].years.length; j++) {

                if (i==0) {
                    restructuredData[j] = new Array();
                    var currentYear = data[i].years[j].year;

                    //Update min/max years in data
                    minYear = (currentYear < minYear) ? currentYear : minYear;
                    maxYear = (currentYear > maxYear) ? currentYear : maxYear;
                }

                restructuredData[j].push(
                        {
                            'name': data[i].name,
                            'continent': data[i].continent,
                            'gdp': data[i].years[j].gdp,
                            'life_expectancy': data[i].years[j].life_expectancy,
                            'population': data[i].years[j].population,
                            'year': currentYear,
                            'longitude': data[i].longitude,
                            'latitude':data[i].latitude,
                            'country_id':data[i].country_id,
                            'top_partners':data[i].years[j].top_partners,
                            'year':data[i].years[j].year
                        });
            }
        }
        return restructuredData;
    }

    var intransition = false;

    var dropdowns = d3.selectAll("select");
    dropdowns.on("change", function() {
        UpdateFilters();
        ConstructPieLayout();
        ConstructAsterLayout();
        BuildComponents();
        UpdateViz();

    });

    var countrySortingE = document.getElementById("country_sorting_val");
    var countrySortingVal = countrySortingE.options[countrySortingE.selectedIndex].value;
    var countrySortingValPrev = countrySortingVal;

    var asterSortingE = document.getElementById("aster_sorting_val");
    var asterSortingVal = asterSortingE.options[asterSortingE.selectedIndex].value;

    var continentSortingVal = d3.select("input[value=\"continent_sorting_val\"]").node().checked;
    var continentSortingValPrev = continentSortingVal;


    var screen_width = 1293;
    var screen_height = 710;
    var svg_width = screen_width * .75;
    var svg_height = screen_height * .95;
    var svgX_offset = 0;
    var svgY_offset = 20;
    var svg_cx = svg_width/2 + svgX_offset;
    var svg_cy = svg_height/2 + svgY_offset;

    //Grouping Reference
    var svg = d3.select("#bottom_left_panel").append("svg")
            .attr("width", svg_width)
            .attr("height", svg_height)
            .attr("transform", "translate(" + svg_width/2 + "," + svg_height/2 + ")");

    //Group Ref in order of drawing
    var g_border = svg.append("g").attr("class", "border");
    var g_chords = svg.append("g").attr("class", "chords");
    var g_nodes = svg.append("g").attr("class", "nodes");
    var g_labels = svg.append("g").attr("class", "labels");

    var aster_offset = 25;
    var aster_width = 300;
    var aster_height = 300;
    var asterYOffset = 0;
    var aster_radius = Math.min(aster_width, aster_height) / 2;
    var aster_innerRadius = 0.3 * aster_radius;
    var total_exportSum;
    var svg_aster = d3.select("#right_panel").append("svg")
            .attr("width", aster_width)
            .attr("height", aster_height)
            .append("g")
            .attr("transform", "translate(" + aster_width / 2 + "," + (aster_height/2 + asterYOffset) + ")");

    var innerSlices, outerSlices, aster_arc, aster_data, aster_outlineArc;

//    var g = svg.append("g");

    //Data Holders
    var graph = {nodes: [], links: []};
    var restructuredData;
    var continentListing;

    //Label Loc offset
    var padTextX = 22;
    var padTextY = 4;

    //////////////////////////////////////
    // Graph Init layouts
    //////////////////////////////////////
    // Force layout
    var link;
    var force = d3.layout.force()
            .charge(-50)
            .linkDistance(10)
            .linkStrength(0);
    // Pie Layout
    var r, arc, pie, arc_outer, pieData;
    var R_FACTOR = 1.45;
    // DOM
    var nodes, circs, labels, paths, links, chords;

    var startUp = true;
    var selectedCountry = "United States";

    var mutualScale = d3.scale.linear()
            .domain([9, 4.5, 0])
            .range(["green", "blue", "red"]);

    var continentColorScale = d3.scale.category10();

    var timeSlider = document.getElementById("slider-time");
    var yearIndex = timeSlider.value - timeSlider.min;

    //Apply Input Interaction
//    var inputs = d3.selectAll("input");
    d3.select("input[id=\"slider-time\"]").on("input", function() {

        console.log(true);

        yearIndex = timeSlider.value - timeSlider.min;

        UpdateFilters();
        ConstructPieLayout();
        ConstructAsterLayout();
        BuildComponents();
        UpdateViz();
    });


    d3.select("input[value=\"continent_sorting_val\"]").on("change", function() {

        yearIndex = timeSlider.value - timeSlider.min;

        UpdateFilters();
        ConstructPieLayout();
        ConstructAsterLayout();
        BuildComponents();
        UpdateViz();
    });


    //////////////////////////////////////
    // Read In Data
    //////////////////////////////////////
    d3.json( "data/countries_1995_2012.json", function(error, data) {
        //Calculate year range
        restructuredData = CalculateRestructuredData(data);     //New Data
        continentListing = NumberCountriesPerContinent(data);

        UpdateFilters();
        ConstructPieLayout();
        ConstructAsterLayout();
        BuildComponents();
        UpdateViz();
    });


    function BuildComponents(){

        AddLinks();
        AddNodes();
        AddLabels();
        AddSlices();

        chords.exit().remove();
        nodes.exit().remove();
        labels.exit().remove();
    }

    function AddLinks(){

        chords = g_chords.selectAll("path")
                .data( graph.links );

        chords.enter()
                .append("path")
                .attr("class", "chord")
                .attr("name", function(d){
                    return d.source.name + "---" + d.target.name;
                })
                .attr("stroke", "black")
                .attr("fill", "grey");
    }

    function AddNodes(){

        nodes = g_nodes.selectAll("circle")
                .data(pieData);

        nodes.enter()
                .append("circle")
                .attr("class", "node")
                .attr("name", function(d){
                    return d.name;
                })
                .attr("r", 6)
                .attr("transform", function(d) {
                        return "translate(" + svg_cx + "," + svg_cy + ")";
                })
                .on("mouseover", mouseOverEvent)
                .on("mouseout", mouseOutEvent);
    }

    function AddLabels(){
        labels = g_labels.selectAll("text")
                .data( pieData );

        labels.enter()
                .append("text")
                .attr("class", "node")
                .attr("name", function(d){
                    return d.name;
                })
                .text(function (d) {  return d.name;  })
                .attr("text-anchor", "left")
                .attr("x", function (d) { return 0; })
                .attr("y", function (d) { return 0; })
                .attr("transform", function(d) {
                    return "translate(" + (svg_cx) + "," + (svg_cy) + ")rotate(" + 0 + ")";
                })
                .attr("font-family", "sans-serif")
                .attr("font-size", "10px")
                .attr("fill", "black")
                .on("mouseover", mouseOverEvent)
                .on("mouseout", mouseOutEvent);

    }

    function AddSlices(){
        innerSlices = svg_aster.selectAll(".solidArc")
                .data(aster_data);

        innerSlices
                .enter()
                .append("path")
                .attr("fill", function(d) {
                    var nullColor = "grey";
                    var ranking = GetMutualRanking(d.data.source, d.data.partner);
                    return (ranking >= 0) ? mutualScale(ranking) : nullColor;
                })
                .attr("class", "solidArc")
                .attr("stroke", "black")
                .attr("d", aster_arc);
//            .on('mouseover', tip.show)
//            .on('mouseout', tip.hide);

        outerSlices = svg_aster.selectAll(".outlineArc")
                .data(aster_data);

        outerSlices
                .enter()
                .append("path")
                .attr("fill", "none")
                .attr("stroke", "gray")
                .attr("class", "outlineArc")
                .attr("d", aster_outlineArc);

        innerSlices.exit().remove();
        outerSlices.exit().remove();
    }


    function ConstructAsterLayout() {

        var currentTopPartners = []
        graph.links.filter(function (d) {
            if (d.source.name == selectedCountry) {
                d.source.top_partners.forEach( function(e,i) {
                    if (e.country_id == d.target.country_id) {
                        currentTopPartners.push({
                            "source": d.source,
                            "partner": d.target,
                            "p_total_export": GetTotalExport(e),
                            "p_proximity" : GetProximity(d.source, d.target),
                            "p_mutuality" : GetMutualRanking(d.source, d.target)
                        });
                    }
                })
            }
        });

        total_exportSum = 0;
        currentTopPartners.forEach( function(d){
            total_exportSum = total_exportSum + d.p_total_export;
        });

        currentTopPartners.forEach( function(d){
            d.total_exportSum = total_exportSum;
        });

        var aster_pie = d3.layout.pie()
                .sort( compareAsterNew )
                .value(function(d) { return 1; });

        aster_arc = d3.svg.arc()
                .innerRadius(aster_innerRadius)
                .outerRadius(function (d,i) {
                    var minR = (aster_innerRadius+aster_offset);
                    var percentExport = (d.data.p_total_export/ d.data.total_exportSum);
                    return (aster_radius - minR) * percentExport + minR;
                });

        aster_outlineArc = d3.svg.arc()
                .innerRadius(aster_innerRadius)
                .outerRadius(aster_radius);


        aster_data = aster_pie( currentTopPartners );

    }


    //Part 2: Circular
    function ConstructPieLayout() {

        r = .5*Math.min(svg_height, svg_width)/R_FACTOR;

        arc = d3.svg.arc()
                .outerRadius(r);

        pie = d3.layout.pie()
                .sort(compareCountries) // Sorting by categories
                .value(function(d, i) {
                    return 1;  // We want an equal pie share/slice for each point
                });

        pieData = pie(graph.nodes).map(function (d, i) {

            // Needed to caclulate the centroid
            d.innerRadius = 0;
            d.outerRadius = r;

            d.data.startAngle = d.startAngle;
            d.data.endAngle = d.endAngle;

            d.data.x = arc.centroid(d)[0]*2.0 + svg_cx;
            d.data.y = arc.centroid(d)[1]*2.0 + svg_cy;

            return d.data;
        });

        ConstructContinentPieLayout();
    }

    //Part 2: Circular
    function ConstructContinentPieLayout() {

        var r1 = .5*Math.min(svg_height, svg_width)/R_FACTOR;

        var arc1 = d3.svg.arc()
                .innerRadius(r1)
                .outerRadius(r1+padTextX);

        var pie1 = d3.layout.pie()
                .sort( function(a,b){
                    return d3.ascending(a["continent"], b["continent"]);
                })
                .value(function(d, i) {
                    return d.value;
                });

        var p = pie1( (continentSortingVal) ? continentListing : [{value: 1}]);

        var myPath = g_border.selectAll("path").data(p);

        myPath.enter()
                .append("path");
        myPath
                .attr("fill", function(d,i) {
                    console.log( continentSortingVal);
                    return (continentSortingVal) ? continentColorScale(i) : "silver";
                })
                .attr("class", "path")
                .attr("stroke", "black")
                .attr("d", function(d){
                    return arc1(d);
                })
                .attr("transform", function(d){
                    return "translate(" + svg_cx + "," + svg_cy + ")";
                })

        myPath.exit().remove();

    };

    function UpdateViz(){
        graph_update();
        if (startUp) { startUp = false; }
    }

    function UpdateChords(transTime){

        chords.transition()
                .delay(0)
                .duration(transTime)
                .attr("d", function (d) {
                    if (d.source.name == selectedCountry) {
                        return DrawPath(d.source, d.target);
                    }
                })
                .attr("stroke", "black")
                .attr("fill", function (d) {
                    var nullColor = "grey";
                    if (d.source.name == selectedCountry) {
                        var ranking = GetMutualRanking(d.source, d.target);
                        return (ranking >= 0) ? mutualScale(ranking) : nullColor;
                    }
                    else{
                        return nullColor
                    }
                });
    }

    function UpdateNodes(transTime){

        nodes.transition()
                .delay(0)
                .duration(transTime)
                .each("start", function(d) {
                    intransition = true;
                })
                .attrTween("transform", function(d, i, a) {
                    var oldCoords = d3.transform(d3.select(this).attr("transform")).translate;
                    return ParameterizeNode(oldCoords, [d.x, d.y]);
                })
                .each("end", function(d) {
                    intransition = false;
                })

        nodes.classed("node--source", function(d){
            return d.name == selectedCountry;
        });
    }

    function UpdateLabels(transTime) {

        labels.transition()
                .delay(0)
                .duration(transTime)
                .each("start", function (d) {

                    var oldRotate = d3.transform(d3.select(this).attr("transform")).rotate;
                    var oldCoords = d3.transform(d3.select(this).attr("transform")).translate;

                    var leftHem = oldCoords[0] <= svg_cx + padTextY ? true : false;
                    var tx = (leftHem) ? oldRotate + 180 : oldRotate;
                    var ty = (leftHem) ? 2 * padTextY : 0;

                    d3.select(this).attr("transform", function (d) {
                        return "translate(" + oldCoords[0] + "," + oldCoords[1] + ")rotate(" + tx + ")translate(" + 0 + "," + ty + ")";
                    });
                    d3.select(this).attr("text-anchor", function (d) {
                        return "start";

                    });
                })
                .attrTween("transform", function (d, i, a) {
                    var oldCoords = d3.transform(d3.select(this).attr("transform")).translate;
                    var oldRotate = d3.transform(d3.select(this).attr("transform")).rotate;
                    return ParameterizeLabel(oldCoords, d, [padTextX, padTextY], oldRotate);

                })
                .each("end", function (d) {
                    var shift = angle(d, 0, 0) < 0 ? 1.0 : -1.0;
                    d3.select(this).attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y +
                                ")rotate(" + angle(d, -90, 90) +
                                ")translate(" + shift * padTextX + "," + padTextY + ")";
                    });
                    d3.select(this).attr("text-anchor", function (d) {
                        return angle(d, 0, 0) < 0 ? "start" : "end";

                    });
                });
    }


    function UpdateSlices(){
        innerSlices
                .attr("fill", function(d) {
                    var nullColor = "grey";
//                    if (d.data.source.name == selectedCountry) {
                    var ranking = d.data.p_mutuality;
                    return (ranking >= 0) ? mutualScale(ranking) : nullColor;
//                    return "red";
                })
                .attr("class", "solidArc")
                .attr("stroke", "black")
                .attr("d", aster_arc);
//            .on('mouseover', tip.show)
//            .on('mouseout', tip.hide);

        outerSlices
                .attr("fill", "none")
                .attr("stroke", "black")
                .attr("class", "outlineArc")
                .attr("d", aster_outlineArc);
    }


    function graph_update(){

        var transTime = 0;
        if (countrySortingValPrev != countrySortingVal){
            transTime = 1000;
            countrySortingValPrev = countrySortingVal;
        }
        if (continentSortingValPrev != continentSortingVal){
            transTime = 1000;
            continentSortingValPrev = continentSortingVal;
        }

        UpdateChords(transTime);
        UpdateNodes(transTime);
        UpdateLabels(transTime);
        UpdateSlices();

    }

    //////////////////////////////////////
    // Country Sorting
    //////////////////////////////////////
    //Sorting functions (New or cached sorting value)
    //Sorting functions (New or cached sorting value)
    function compareCountriesNew(a, b){
        if (countrySortingVal == "name") {          return d3.ascending(a["name"], b["name"]); }
        if (countrySortingVal == "population") {    return b["population"] - a["population"]; }
        if (countrySortingVal == "gdp") {           return b["gdp"] - a["gdp"]; }
    }

    function compareCountries(a, b) {
        if (continentSortingVal) {
            var ans = d3.ascending(a["continent"], b["continent"]);
            return (ans != 0) ? ans : compareCountriesNew(a,b);
        }
        else{
            return compareCountriesNew(a,b);
        }
    }

    function compareContinents(a, b) {
        if (continentSortingVal) {
            return b.number - a.number;
        }
        else{
            return null;
        }
    }

    function compareAsterNew(a, b){
        if (asterSortingVal == "export_ranking") {  return b.p_total_export - a.p_total_export; }
        if (asterSortingVal == "proximity") {       return a.p_proximity - b.p_proximity; }
        if (asterSortingVal == "mutuality") {       return b.p_mutuality - a.p_mutuality; }
    }


    function mouseOverUpdateComponents(){
        UpdateChords(0);
        ConstructAsterLayout();
        AddSlices();
        UpdateSlices();
    }

    //////////////////////////////////////
    // Mouse Events
    //////////////////////////////////////
    function mouseOverEvent(d){

        if (!intransition) {
            selectedCountry = d.name;

            nodes.each(function (n) {
                n.target = false;
                n.source = false;
            })
            nodes.classed("hidden", false);

            chords
                    .classed("chord--source", function (l) {
                        if (l.source === d) {
                            l.source.source = true;
                            return l.target.target = true;
                        }
                    });

            mouseOverUpdateComponents();

            nodes
                    .classed("node--target", function (n) { return n.target;    })
                    .classed("node--source", function (n) { return n.source;    })
                    .classed("hidden", function (n) {   return !(n.target || n.source); });
            labels
                    .classed("hidden", function (n) {   return !(n.target || n.source); });

        }
    }

    function mouseOutEvent(d){
        chords.classed("link--target", false).classed("link--source", false);
        nodes.classed("node--target", false).classed("hidden", false);
        labels.classed("hidden", false);
    }

    //////////////////////////////////////
    // Country Rankings
    //////////////////////////////////////
    function GetMutualRanking(sourceExporter, targetExporter){
        var val = -1
        var MAX_PARTNERS = 10;
        targetExporter.top_partners.forEach(function (partner, i) {
            if (partner.country_id == sourceExporter.country_id) {
                val = (MAX_PARTNERS-1)-i;   //indexed
            }
        })
        return val;
    }
    function GetProximity(sourceExporter, targetExporter){
        var dx = targetExporter.latitude - sourceExporter.latitude;
        var dy = targetExporter.longitude - sourceExporter.longitude;
        var dist = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
        return dist
    }

    function GetTotalExport(partnerExporter){
        return partnerExporter.total_export;
    }

    //////////////////////////////////////
    // Math Helpers
    //////////////////////////////////////
    // Updated Angle Calculation Function...
    function angle(d, offset, threshold) {
        //var theta = Math.atan2(d.y - svg_height/2, d.x - svg_width/2) * 180 / Math.PI;
        var a = (d.startAngle + d.endAngle) * 90 / Math.PI + offset;
        return a > threshold ? a - 180 : a;
    }

    function Polar2Cartesian(theta, radius){

        var x_coord = radius * Math.cos(theta - Math.PI/2.0) + svg_cx;
        var y_coord = radius * Math.sin(theta - Math.PI/2.0) + svg_cy;
        return {"x" : x_coord, "y" : y_coord};
    }

    function DrawPath(source, target) {
        var p = "M" + Polar2Cartesian( source.startAngle, r).x + "," + Polar2Cartesian( source.startAngle, r).y +
                "C" + svg_cx                                   + " " + svg_cy                                   +
                " " + svg_cx                                   + " " + svg_cy                                   +
                " " + Polar2Cartesian( target.startAngle, r).x + " " + Polar2Cartesian( target.startAngle, r).y +
                "L" + Polar2Cartesian( target.endAngle, r).x   + "," + Polar2Cartesian( target.endAngle, r).y   +
                "C" + svg_cx                                   + " " + svg_cy                                   +
                " " + svg_cx                                   + " " + svg_cy                                   +
                " " + Polar2Cartesian( source.endAngle,r).x    + " " + Polar2Cartesian( source.endAngle, r).y   +
                "L" + Polar2Cartesian( source.startAngle,r).x  + "," + Polar2Cartesian( source.startAngle, r).y +
                "Z";
        return p;
    }

//    function ParameterizeChord(old_source, old_target, source, target) {
//        return function (t) {
//
//            var s1 = ParameterizePoint(
//                    [old_source[0], old_source[1]],
//                    [Polar2Cartesian(source.startAngle, r).x, Polar2Cartesian(source.startAngle, r).y],
//                    t
//            );
//
//            var s2 = ParameterizePoint(
//                    [old_target[0], old_target[1]],
//                    [Polar2Cartesian(target.startAngle, r).x, Polar2Cartesian(target.startAngle, r).y],
//                    t
//            );
//            var s3 = ParameterizePoint(
//                    [old_target[0], old_target[1]],
//                    [Polar2Cartesian(target.endAngle, r).x, Polar2Cartesian(target.endAngle, r).y],
//                    t
//            );
//            var s4 = ParameterizePoint(
//                    [old_source[0], old_source[1]],
//                    [Polar2Cartesian(source.endAngle, r).x, Polar2Cartesian(source.endAngle, r).y],
//                    t
//            );
//
//            return DrawPath(source, target);
//
//        }
//    }

    function ParameterizeNode(old_d, new_d) {
        return function (t) {

            var theta1 = Math.atan2(old_d[1] - svg_cy, old_d[0] - svg_cx);
            var theta2 = Math.atan2(new_d[1] - svg_cy, new_d[0] - svg_cx);
            var delta = theta2 - theta1;

            var dx = r * Math.cos(theta1 + delta * t) + svg_cx;
            var dy = r * Math.sin(theta1 + delta * t) + svg_cy;

            return "translate(" + (dx) + "," + (dy) + ")";
        }
    }

//    function ParameterizePoint(old_d, new_d, t) {
//
//            var theta1 = Math.atan2(old_d[1] - svg_cy, old_d[0] - svg_cx);
//            var theta2 = Math.atan2(new_d[1] - svg_cy, new_d[0] - svg_cx);
//            var delta = theta2 - theta1;
//
//            var dx = r * Math.cos(theta1 + delta * t) + svg_cx;
//            var dy = r * Math.sin(theta1 + delta * t) + svg_cy;
//
//            return [ dx , dy ];
//    }

    function ParameterizeLabel(old_d, d, offset_d, old_rotate) {
        return function (t) {

            //Label Orientation - if on left hemisphere
            var wasFlipLabel = old_d[0] < svg_cx + padTextY ? true : false;
            var shouldFlipLabel = d.x < svg_cx + padTextY ? true : false;

            //Label adjustments
            var a = (!wasFlipLabel) ? angle(d, -90, 90) : angle(d, -90, 90) - 180;
            if (wasFlipLabel != shouldFlipLabel){
                a = (shouldFlipLabel) ? a - 180 : a + 180;
            }
            if (a < 0 && a <-180){  a = 360 + a; }

            //Angle Diffs
            var theta1 = Math.atan2(old_d[1] - svg_cy, old_d[0] - svg_cx);
            var theta2 = Math.atan2(d.y - svg_cy, d.x - svg_cx);
            var delta = theta2 - theta1;
            var deltaR = (a - old_rotate);

            //Ignore Small changes
            var rad_diff = delta / (Math.PI * 2);
            if ((Math.abs(rad_diff) < .003 || Math.abs(rad_diff) > .98)){
                t=1;        //Dont paramterize, just go to final value
            }

            var dx_t = r * Math.cos(theta1 + delta * t) + svg_cx;// + offset_d[0];
            var dy_t = r * Math.sin(theta1 + delta * t) + svg_cy;// + offset_d[1];
            var dr = (old_rotate + deltaR*t);

            return "translate(" + dx_t + "," + dy_t + ")rotate(" + dr + ")translate(" + offset_d[0] + "," + offset_d[1] + ")";

        }
    }

    function NumberCountriesPerContinent(data) {
        var continentListing = d3.nest()           //Aggregated
                .key(function (d) {
                    return d.continent
                })
                .rollup(function (d) {
                    return {"sumCountries" : d3.sum( d, function(g){ return 1; } ) };
                }).entries(data);

        continentListing.forEach(function(d){      //Rename variables
            d.continent = d.key;
            d.value = d.values.sumCountries;
        });
        return continentListing;
    }



</script>
</body>
</html>